(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5398],{10156:e=>{"use strict";e.exports={getGlobalPrivyAuthUrl:()=>"https://auth.privy.io"}},16830:(e,r,t)=>{"use strict";t.d(r,{A:()=>p});var a=t(10156),o=t(39907);let n="cla04x0d00002nyb6oofp5dqh",i=o.env.VERCEL_GIT_COMMIT_SHA,s="pk_live_51IVGUtF66LfGv8cgubvAHN9hcEUMJJOvprWKjAUEhuWCQsQZHGE5b1PDzChVsiIjyCOCbmqpgtH9cQAemzTIuG3600x1ub2mo9",c="J64Bl2g14xIjQ0Vp6Xo0lPPu1oIdFx2G6yg6bVGgihA=";if("string"!=typeof n)throw Error("NEXT_PUBLIC_PRIVY_APP_ID needs to be defined");let d=(0,a.getGlobalPrivyAuthUrl)(),l="https://dashboard.privy.io";if(!l||"string"!=typeof l)throw Error("NEXT_PUBLIC_DASHBOARD_PRIVY_AUTH_URL must be defined");let u="https://dashboard.privy.io";u||console.warn("No Privy dashboard URL found, some dashboard admin actions like reporting to Slack will not work.");let y="4df5e2316331463a9130964bd6078dfa",v="fe9c30fc-3bc5-4064-91e2-6ab5887f8f4d";if("string"!=typeof y)throw Error("NEXT_PUBLIC_PRIVY_INFURA_ID must be set");if("string"!=typeof v)throw Error("NEXT_PUBLIC_PRIVY_BLAST_ID must be set");if("string"!=typeof s)throw Error("NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY must be set");if("string"!=typeof c)throw Error("NEXT_PUBLIC_DELEGATED_ACTIONS_TEE_PUBLIC_KEY must be set");let p=Object.freeze({isTest:!1,isProduction:!0,isStaging:!1,isDevelopment:!1,PRIVY_APP_ID:n,PRIVY_ENV:"production",GLOBAL_PRIVY_AUTH_URL:d,DASHBOARD_PRIVY_AUTH_URL:l,DASHBOARD_URL:u,PRIVY_INFURA_ID:y,PRIVY_BLAST_ID:v,GIT_COMMIT_SHA:i,SPECIAL_EVENT_SIGNUP_ENABLED:!0,DEV_APP_USER_LIMIT:150,STRIPE_PUBLISHABLE_KEY:s,DELEGATED_ACTIONS_TEE_PUBLIC_KEY:c})},62729:(e,r,t)=>{"use strict";t.d(r,{A:()=>i});var a=t(39535),o=t(30066);class n extends o.i{set(e,r){let t=this.getWalletStorageKey(e),a={share:r.share,deviceId:r.deviceId};this._set(t,a)}get(e){let r=this.getWalletStorageKey(e);return this._get(r)}del(e){let r=this.getWalletStorageKey(e);this._del(r)}getWalletStorageKey(e){let{appId:r,userId:t,address:o}=e;return"privy_wallet:".concat(r,":").concat(t,":").concat((0,a.qi)(o)?(0,a.py)(o):o)}constructor(e){super(e)}}let i=(()=>{try{if("undefined"!=typeof globalThis&&globalThis.localStorage){globalThis.localStorage.setItem("privy-storage-check","t");let e=globalThis.localStorage.getItem("privy-storage-check");if(globalThis.localStorage.removeItem("privy-storage-check"),"t"!==e)throw console.debug("Localstorage check failed"),Error("Unable to ping localStorage");return new n(globalThis.localStorage)}}catch(e){e instanceof DOMException&&"SecurityError"===e.name?console.debug("Security settings in your browser prevent access to local storage, used for persisting wallet state. Wallet information will be stored in-memory."):console.debug("Unknown issue loading local storage, used for persisting wallet state. Wallet information will be stored in-memory.")}return new n(new o._)})()},17890:(e,r,t)=>{"use strict";t.d(r,{A:()=>ey});var a=t(39535),o=t(28192),n=t(64291),i=t(46394),s=t(84192),c=t(18566),d=t(4894),l=t(26118);let u=["eth_sign","eth_populateTransactionRequest","eth_signTransaction","eth_sendTransaction","personal_sign","eth_signTypedData_v4","csw_signUserOperation","secp256k1_sign"];var y=t(94531),v=t(2560);async function p(e,r){return await e.wallet.sign({hash:r})}var w=t(16830),f=t(76094),_=t(77242),h=t(23360),m=t(44569),g=t(82927),b=t(19075),k=t(49857),P=t(33203),I=t(62808),T=t(33808),A=t(40683),S=t(54973),E=t(98158),K=t(23955),x=t(77535),F=t(97474),C=t(70323),U=t(1409),R=t(93381),N=t(31404),q=t(48008),O=t(62978),D=t(54968),M=t(87873),G=t(49288),L=t(42387),B=t(46658),V=t(6722),j=t(95427),z=t(24385);let W=(0,t(54676).x)({id:6900,name:"Animechain Testnet",nativeCurrency:{decimals:18,name:"ANIME",symbol:"ANIME"},rpcUrls:{default:{http:["https://rpc-animechain-testnet-i8yja6a1a0.t.conduit.xyz"],webSocket:["wss://rpc-animechain-testnet-i8yja6a1a0.t.conduit.xyz"]}},blockExplorers:{default:{name:"Explorer",url:"https://explorer-animechain-testnet-i8yja6a1a0.t.conduit.xyz"}}}),Y={[_.D.id]:_.D,[h.R.id]:h.R,[m.Y.id]:m.Y,[g.m.id]:g.m,[b.C.id]:b.C,[k.E.id]:{...k.E,rpcUrls:{default:{http:["https://thrumming-thrumming-pool.base-mainnet.quiknode.pro/afc8a0038cd744f30fd210e6f8c6b59ed5817bd7"]}}},[P.C.id]:P.C,[I.Z.id]:I.Z,[T.v.id]:T.v,[A._.id]:A._,[S.A.id]:S.A,[E.p.id]:E.p,[K.G.id]:K.G,[x.O.id]:x.O,[F.h.id]:F.h,[C.G.id]:{...C.G,rpcUrls:{default:{http:["https://quaint-morning-star.ethereum-sepolia.quiknode.pro/0063bd92e4f0adaa5b76cbd168121be661100ed9/"]}}},[U.y.id]:U.y,[l.r.id]:{...l.r,rpcUrls:{default:{http:["https://crimson-wider-silence.quiknode.pro/50060fe02eaca407606719d97f4f204f28da43ed"]}}},[R._.id]:R._,[N.Z.id]:N.Z,[q.F.id]:q.F,[O.R.id]:O.R,[D.t.id]:D.t,[M.i.id]:M.i,[G.n.id]:G.n,[L.E.id]:L.E,[B.n.id]:B.n,[V.L.id]:V.L,[j.q.id]:j.q,[z.a.id]:z.a,[W.id]:W},H={8453:"https://base-mainnet.blastapi.io",84531:"https://base-goerli.blastapi.io"},Q=e=>{let r=Y[e];if(!r)throw Error("Unsupported chainId ".concat(e));return r},Z=e=>{var r,t;let a;let o=Q(e);if(null===(r=o.rpcUrls.infura)||void 0===r?void 0:r.http[0]){if(!w.A.PRIVY_INFURA_ID)throw Error("Missing Infura ID for RPC URL");a=(0,f.j8)(o.rpcUrls.infura.http[0],w.A.PRIVY_INFURA_ID)}else if(H[e]){if(!w.A.PRIVY_BLAST_ID)throw Error("Missing Blast ID for RPC URL");a=(0,f.j8)(H[e],w.A.PRIVY_BLAST_ID)}else a=null===(t=o.rpcUrls.default)||void 0===t?void 0:t.http[0];if(!a)throw Error("No RPC url found for ".concat(e));return a};var J=t(1048).Buffer;let X={0:"legacy",1:"eip2930",2:"eip1559",3:"eip4844"},$={legacy:0,eip2930:1,eip1559:2,eip4844:3},ee=e=>void 0!==e?BigInt(e):void 0;function er(e){var r,t,a,n;let c;let{type:d=2,...u}="string"==typeof e?JSON.parse(e):e;u.accessList&&Array.isArray(u.accessList)?c=u.accessList.map(e=>Array.isArray(e)?{address:e[0],storageKeys:e[1]}:e):u.accessList&&(c=Object.entries(u.accessList).map(e=>({address:e[0],storageKeys:e[1]})));let y=Number(null!==(r=u.chainId)&&void 0!==r?r:l.r.id),v=(0,i.q)(u.data)?u.data:u.data?(0,s.nj)(Uint8Array.from(u.data)):void 0,p=u.nonce?Number(u.nonce):void 0;if(0===d)return{...u,type:X[d],chainId:y,data:v,value:ee(u.value),gasPrice:ee(u.gasPrice),gas:ee(null!==(t=u.gas)&&void 0!==t?t:u.gasLimit),nonce:p,accessList:void 0,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(1===d)return{...u,type:X[d],chainId:y,data:v,value:ee(u.value),gasPrice:ee(u.gasPrice),gas:ee(null!==(a=u.gas)&&void 0!==a?a:u.gasLimit),nonce:p,accessList:c,maxFeePerGas:void 0,maxPriorityFeePerGas:void 0};if(2===d)return{...u,type:X[d],chainId:y,data:v,value:ee(u.value),gas:ee(null!==(n=u.gas)&&void 0!==n?n:u.gasLimit),nonce:p,accessList:c,maxFeePerGas:ee(u.maxFeePerGas),maxPriorityFeePerGas:ee(u.maxPriorityFeePerGas),gasPrice:void 0,maxFeePerBlobGas:void 0};throw new o.Pi("invalid_request_arguments","Unsupported transaction type: ".concat(d))}function et(e){if("private-key"===e.entropyType)return J.from(e.entropy);let r=e.wallet.getHdKey().privateKey;if(!r)throw new o.Pi("wallet_not_on_device","Unable to read private key from HD account");return J.from(r)}async function ea(e,r,t){return eu(e.wallet.address,r),(0,n.personalSign)({privateKey:et(e),data:t})}async function eo(e,r,t,a){return eu(e.wallet.address,r),(0,n.signTypedData)({data:t,privateKey:et(e),version:a})}async function en(e,r,t,a){let o=function(e){var r,t;let{userOperation:a,chainId:o,entrypointAddress:n}=e,i=(0,y.h)([{name:"sender",type:"address"},{name:"nonce",type:"uint256"},{name:"initCode",type:"bytes32"},{name:"callData",type:"bytes32"},{name:"callGasLimit",type:"uint256"},{name:"verificationGasLimit",type:"uint256"},{name:"preVerificationGas",type:"uint256"},{name:"maxFeePerGas",type:"uint256"},{name:"maxPriorityFeePerGas",type:"uint256"},{name:"paymasterAndData",type:"bytes32"}],[a.sender,a.nonce,(0,v.S)(null!==(r=a.initCode)&&void 0!==r?r:"0x"),(0,v.S)(a.callData),a.callGasLimit,a.verificationGasLimit,a.preVerificationGas,a.maxFeePerGas,a.maxPriorityFeePerGas,(0,v.S)(null!==(t=a.paymasterAndData)&&void 0!==t?t:"0x")]),s=(0,v.S)(i),c=(0,y.h)([{name:"userOpHash",type:"bytes32"},{name:"entryPoint",type:"address"},{name:"chainId",type:"uint256"}],[s,n,BigInt(o)]);return(0,v.S)(c)}({userOperation:r,chainId:a,entrypointAddress:t});return await p(e,o)}async function ei(e,r){return await e.wallet.sign({hash:r})}async function es(e,r){let{method:t,params:a}=r;if(!u.includes(t))throw Error("Unsupported JSON RPC method: ".concat(t));switch(t){case"personal_sign":return{method:t,data:await ea(e,a[1],a[0])};case"eth_populateTransactionRequest":return{method:t,data:await ed(e,a[0])};case"eth_sign":return eu(e.wallet.address,a[0]),{method:t,data:await e.wallet.signMessage({message:a[1]})};case"eth_signTypedData_v4":{let r=function(e){if("string"!=typeof e)return e;try{let r=JSON.parse(e);return void 0!==r.domain.chainId&&(r.domain.chainId=Number(r.domain.chainId)),r}catch(e){throw Error("Failed to deserialize message with error: ".concat(e))}}(a[1]);return{method:t,data:await eo(e,a[0],r,n.SignTypedDataVersion.V4)}}case"eth_signTransaction":{let r=er(a[0]);return{method:t,data:await e.wallet.signTransaction(r)}}case"eth_sendTransaction":return{method:t,data:await ec(e,a[0])};case"csw_signUserOperation":{let[r,o,n]=a;return{method:t,data:await en(e,r,o,n)}}case"secp256k1_sign":{let[r]=a;return{method:t,data:await ei(e,r)}}}}async function ec(e,r){try{let{chainId:t=l.r.id,...a}=er(r),o=Q(t),n=Z(t),i=(0,c.F)({chain:o,account:e.wallet,transport:(0,d.L)(n)});return await i.sendTransaction(a)}catch(e){throw el(e)}}async function ed(e,r){try{let{chainId:t=l.r.id,...a}=er(r),o=Q(t),n=Z(t),i=(0,c.F)({account:e.wallet.address,chain:o,transport:(0,d.L)(n)}),{type:s,...u}=await i.prepareTransactionRequest(a);return{...u,type:$[s]}}catch(e){throw el(e)}}function el(e){let r=e.code,t=e.reason;return"INSUFFICIENT_FUNDS"===r?new o.Pi("insufficient_funds","Wallet has insufficient funds for this transaction"):t?new o.Pi("error",t):"string"==typeof e?Error(e):e}function eu(e,r){if(!(0,a.LH)(e,r))throw Error("Signer ".concat(e," can not sign on behalf of ").concat(r))}function ey(e,r){if(!(0,a.qi)(e.wallet.address))throw new o.Pi("invalid_request_arguments","Failed to service JSON RPC request: missing or invalid wallet address");return es(e,r)}},40049:(e,r,t)=>{"use strict";t.d(r,{A:()=>n});var a=t(28192),o=t(75185);function n(e,r){let{request:t,signingPublicKey:n,publicKey:i,hdWalletIndex:s}=r;if(void 0!==s&&0!==s&&void 0===n)throw new a.Pi("invalid_request_arguments","signingPublicKey must be passed when signing with a wallet with an HD index that is not 0.");return o.p({keypair:e,request:t,expectedPublicKey:null!=n?n:i})}},15818:(e,r,t)=>{"use strict";t.d(r,{h6:()=>f,kL:()=>w,io:()=>p,jt:()=>T.A,Zv:()=>A.A,uP:()=>P,JG:()=>m,_U:()=>K});var a=t(36073),o=t(82926),n=t.n(o),i=t(39535),s=t(85451),c=t(28192);let d={"user-passcode":"user_passcode_derived_recovery_key",privy:"privy_generated_recovery_key","google-drive":"google_drive_recovery_secret",icloud:"icloud_recovery_secret","icloud-native":"icloud_recovery_secret"};var l=t(62729),u=t(10280),y=t(1048).Buffer;async function v(e){let{appId:r,appClientId:t,userId:a,walletAddress:o,accessToken:n,clientType:s,recoveryPassword:l,recoveryMethod:y,recoveryAccessToken:v,recoveryPin:p,recoverySecretOverride:w,iCloudRecordNameOverride:f,createWalletEvent:_}=e,h=l||p;if(void 0!==h&&!(0,i.jt)(h))throw new c.Pi("invalid_request_arguments","Failed to create wallet: invalid recovery pin");if("icloud-native"===y&&(!w||!f))throw new c.Pi("invalid_request_arguments","Failed to create wallet: recoverySecret and iCloudRecordName must be overridden for icloud-native recovery");if("icloud-native"!==y&&(w||f))throw new c.Pi("invalid_request_arguments","Failed to create wallet: recoverySecret and iCloudRecordName can only be overridden for icloud-native recovery");let m=y?d[y]:void 0;m||(m=void 0!==h?"user_passcode_derived_recovery_key":"privy_generated_recovery_key");let g=(0,u.Zw)({recoveryType:m,appId:r,appClientId:t,userId:a,entropyId:o,clientType:s,recoveryPassword:h,recoveryAccessToken:v,accessToken:n,recoverySecretOverride:w,iCloudRecordNameOverride:f,createWalletEvent:_}),{encryptionKey:b,walletRecoveryOutput:k}=await (0,u.cq)(g);return{encryptionKey:b,walletRecoveryOutput:k,recoveryType:m}}async function p(e){let r,{appId:t,appClientId:o,userId:n,accessToken:c,clientType:d,recoveryPassword:y,recoveryMethod:p,recoveryAccessToken:w,recoveryPin:f,recoverySecretOverride:_,iCloudRecordNameOverride:h,createWalletEvent:m,existingEntropy:g}=e,b=[new Uint8Array([]),new Uint8Array([])],k=[new Uint8Array([]),new Uint8Array([])];g?({deviceShares:b}=await (0,i.MR)(g),r=(0,i.Ay)({entropy:g,walletIndex:0})):{deviceShares:b,recoveryShares:k,wallet:r}=await (0,i.sr)();let[P,I]=b,T=await s.QQ({appId:t,appClientId:o,accessToken:c,address:r.address,chainType:"ethereum"}),A=(0,i.t5)(window.location.host,window.location.origin,r.address,T),S=await r.signMessage({message:A}),E=(0,i.hE)();if(g)await s.ry(t,o,c,{message:A,signature:S,device_auth_share:a.K3.encode(I),device_id:E});else{let[e,l]=k,{encryptionKey:g,walletRecoveryOutput:b,recoveryType:P}=await v({appId:t,appClientId:o,userId:n,accessToken:c,walletAddress:r.address,clientType:d,recoveryMethod:p,recoveryPassword:y,recoveryPin:f,recoveryAccessToken:w,recoverySecretOverride:_,iCloudRecordNameOverride:h,createWalletEvent:m}),[T,K]=await Promise.all([(0,i.EN)(g),(0,i.vb)(e,g)]),x=await (0,u.qz)(b);await s.gc({appId:t,appClientId:o,accessToken:c,data:{chain_type:"ethereum",message:A,signature:S,device_id:E,device_auth_share:a.K3.encode(I),recovery_auth_share:a.K3.encode(l),encrypted_recovery_share:a.K3.encode(K.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(K.encryptedShareIV),recovery_type:P,recovery_key_hash:a.K3.encode(T),imported:!1,...x}})}return l.A.set({appId:t,userId:n,address:r.address},{share:a.K3.encode(P),deviceId:E}),{wallet:r,walletIndex:0}}async function w(e){let r,t,{appId:o,appClientId:c,userId:d,accessToken:v,existingEntropy:p}=e,w=[new Uint8Array([]),new Uint8Array([])],f=[new Uint8Array([]),new Uint8Array([])];p?({deviceShares:w}=await (0,i.MR)(p),r=(0,i.kG)({entropy:p,index:0}),t=p):{deviceShares:w,recoveryShares:f,keypair:r,entropy:t}=await (0,i.IV)(256);let _=r.publicKey.toBase58(),[h,m]=w,g=await s.QQ({appId:o,appClientId:c,accessToken:v,address:_,chainType:"solana"}),b=(0,i.zT)(window.location.host,window.location.origin,_,g),k=n().sign.detached(y.from(b),r.secretKey),P=a.K3.encode(y.from(k)),I=(0,i.hE)();if(p)await s.IV(o,c,v,{message:b,signature:P,device_id:I,device_auth_share:a.K3.encode(m)});else{let{encryptionKey:e,walletRecoveryOutput:r}=await (0,u.cq)({recoveryType:"privy_generated_recovery_key"}),{recovery_key:t}=await (0,u.qz)(r),[n,d]=f,[l,y]=await Promise.all([(0,i.EN)(e),(0,i.vb)(n,e)]);await s.gc({appId:o,appClientId:c,accessToken:v,data:{chain_type:"solana",message:b,signature:P,device_id:I,device_auth_share:a.K3.encode(m),recovery_auth_share:a.K3.encode(d),encrypted_recovery_share:a.K3.encode(y.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(y.encryptedShareIV),recovery_type:"privy_generated_recovery_key",recovery_key_hash:a.K3.encode(l),recovery_key:t,imported:!1}})}return l.A.set({appId:o,userId:d,address:_},{share:a.K3.encode(h),deviceId:I}),{entropyType:"hd-entropy",chainType:"solana",wallet:{keypair:r,address:_},walletIndex:0,entropy:t}}async function f(e){let{appId:r,appClientId:t,accessToken:a,hdWalletIndex:o,entropy:n}=e;if(o<=0)throw new c.Pi("invalid_request_arguments","Failed to create additional wallet: invalid wallet index");let d=(0,i.Ay)({entropy:n,walletIndex:o}),l=await s.QQ({appId:r,appClientId:t,accessToken:a,address:d.address,chainType:"ethereum"}),u=(0,i.t5)(window.location.host,window.location.origin,d.address,l),y=await d.signMessage({message:u});return await s.Zn({appId:r,appClientId:t,accessToken:a,data:{message:u,signature:y,hd_node_index:o,chain_type:"ethereum"}}),d}var _=t(92445),h=t(44637);async function m(e){let{cachedWalletData:r,appId:t,appClientId:a,clientAnalyticsId:o,userId:n,hdWalletIndex:s,chainType:d,entropyId:l,entropyIdVerifier:u,accessToken:y,mfaCode:v,mfaMethod:p,relyingParty:w}=e,{entropy:f,entropyType:m}=await (0,h.A)({cache:r,appId:t,appClientId:a,clientAnalyticsId:o,userId:n,entropyId:l,entropyIdVerifier:u,accessToken:y,mfaCode:v,mfaMethod:p,relyingParty:w});if(r&&f===r.entropy&&r.entropyId===l&&r.chainType===d&&r.walletIndex===s)return r;if("private-key"===m&&"ethereum"===d)return{entropy:f,entropyType:m,entropyId:l,entropyIdVerifier:u,chainType:"ethereum",walletIndex:void 0,wallet:(0,i.st)({entropy:f})};if("private-key"===m&&"solana"===d){let e=(0,i.Wi)({entropy:f});return{entropy:f,entropyType:m,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:void 0,wallet:{keypair:e,address:e.publicKey.toBase58()}}}if("hd-entropy"===m&&"ethereum"===d)return{entropy:f,entropyType:m,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:s,wallet:(0,i.Ay)({entropy:f,walletIndex:s})};if("hd-entropy"===m&&"solana"===d){let e=(0,i.kG)({entropy:f,index:s});return{entropy:f,entropyType:m,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:s,wallet:{keypair:e,address:e.publicKey.toBase58()}}}if("hd-entropy"===m&&"bitcoin-segwit"===d)return{entropyType:m,entropy:f,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:s,wallet:(0,_.E)({entropy:f,index:s,pathType:"segwit"})};if("hd-entropy"===m&&"bitcoin-taproot"===d)return{entropyType:m,entropy:f,entropyId:l,entropyIdVerifier:u,chainType:d,walletIndex:s,wallet:(0,_.E)({entropy:f,index:s,pathType:"taproot"})};throw new c.Pi("invalid_request_arguments","Failed to initialize ".concat(d," wallet at index ").concat(s))}var g=t(47670),b=t(24015),k=t(84011);async function P(e){let r,t,o,{appId:n,appClientId:d,clientAnalyticsId:u,userId:y,accessToken:v,clientType:p,entropyId:w,entropyIdVerifier:f,recoveryPassword:_,mfaCode:h,mfaMethod:m,relyingParty:P,recoveryAccessToken:T,recoverySecretOverride:A}=e;if("ethereum-address-verifier"!==f||(0,i.qi)(w)){if("solana-address-verifier"===f&&!(0,i.Zf)(w))throw new c.Pi("invalid_request_arguments","Failed to recover wallet: missing or invalid wallet address")}else throw new c.Pi("invalid_request_arguments","Failed to recover wallet: missing or invalid wallet address");if(void 0!==_&&!(0,i.jt)(_))throw new c.Pi("invalid_request_arguments","Failed to recover wallet: invalid recovery pin");let S=await (0,k.X)({appId:n,appClientId:d,userId:y,accessToken:v,mfaMethod:m,mfaCode:h,relyingParty:P}),{recovery_type:E,recovery_key_derivation_salt:K,recovery_code:x,recovery_key:F,file_id:C,icloud_record_name:U}=await s.j({appId:n,appClientId:d,accessToken:v,entropyId:w,entropyIdVerifier:f});if("icloud_recovery_secret"!==E&&A)throw new c.Pi("invalid_request_arguments","Failed to recover wallet: recovery secret override is only supported for iCloud recovery");if("user_passcode_derived_recovery_key"===E){if(!_)throw new c.Pi("error","Failed to recover wallet: user passcode required and none found");if(!K)throw new c.Pi("error","Failed to recover wallet: cannot retrieve salt for user-supplied passcode derived wallet");r=await (0,i.Ud)(_,a.K3.decode(K))}else if("privy_passcode_derived_recovery_key"===E){if(!K)throw new c.Pi("error","Failed to recover wallet: cannot retrieve salt for Privy-supplied passcode derived wallet");if(!x)throw new c.Pi("error","Failed to recover wallet: cannot retrieve Privy-supplied passcode");r=await (0,i.Ud)(x,a.K3.decode(K))}else if("privy_generated_recovery_key"===E){if(!F)throw new c.Pi("error","Failed to recover wallet: cannot retrieve Privy-generated recovery key");r=await (0,i.kS)(a.K3.decode(F))}else if("google_drive_recovery_secret"===E){let e;if(!C)throw new c.Pi("error","Failed to recover wallet: cannot retrieve fileId for Google Drive recovery secret derived recovery key");if(!T)throw new c.Pi("error","Failed to recover wallet: missing recovery auth access token");try{e=await (0,g.lT)(T,{fileId:C})}catch(e){throw new c.Pi("error","Failed to recover wallet: failed to read recovery secret from Google Drive")}if(!e)throw new c.Pi("error","Failed to recover wallet: missing recovery secret from Google Drive");r=await (0,i.kS)(a.K3.decode(e))}else if("icloud_recovery_secret"===E){let e;if(A)e=A;else{if(!U)throw new c.Pi("error","Failed to recover wallet: cannot retrieve iCloud record name for iCloud recovery secret derived recovery key");if(!T)throw new c.Pi("error","Failed to recover wallet: missing recovery auth access token");try{let{cloudKitContainerIdentifier:r,cloudKitEnvironment:t,cloudKitApiToken:a}=await (0,b.hf)(n,d,v,p);e=await (0,b.WT)({ckWebAuthToken:T,recordName:U,entropyId:w,cloudKitContainerIdentifier:r,cloudKitEnvironment:t,cloudKitApiToken:a,createWalletEvent:(e,r)=>s.$1({appId:n,appClientId:d,accessToken:v,clientId:u,eventName:e,payload:{...r,entropyIdVerifier:f}})})}catch(e){if(e instanceof c.Pi)throw e;throw new c.Pi("unknown_icloud_recovery_error","Failed to recover wallet: unknown issue reading recovery secret from iCloud")}if(!e)throw new c.Pi("error","Failed to recover wallet: missing recovery secret from iCloud")}r=await (0,i.kS)(a.K3.decode(e))}if(!r)throw new c.Pi("error","Failed to recover wallet recovery key");let R=await (0,i.EN)(r),{recoveryAuthShare:N,encryptedRecoveryShare:q,encryptedRecoveryShareIV:O,imported:D}=await I({appId:n,appClientId:d,accessToken:v,entropyId:w,entropyIdVerifier:f,recoveryKeyHash:a.K3.encode(R),mfaToken:S}),M=await (0,i.nz)(a.K3.decode(q),a.K3.decode(O),r);if("ethereum-address-verifier"===f&&D){let{reconstructedWallet:e,reconstructedPrivateKey:r}=await (0,i.Pp)({shares:[M,a.K3.decode(N)],expectedAddress:w});t={entropyId:w,entropyIdVerifier:f,chainType:"ethereum",entropyType:"private-key",wallet:e,entropy:r,walletIndex:void 0},o=r}else if("ethereum-address-verifier"===f){let{entropy:e,wallet:r}=await (0,i.p$)({shares:[M,a.K3.decode(N)],primaryAddress:w,walletIndex:0});o=(t={entropyId:w,entropyIdVerifier:f,chainType:"ethereum",entropyType:"hd-entropy",wallet:r,entropy:e,walletIndex:0}).entropy}else if("solana-address-verifier"===f&&D){let{reconstructedKeypair:e,reconstructedPrivateKey:r}=await (0,i.IX)({shares:[M,a.K3.decode(N)],expectedAddress:w});t={chainType:"solana",entropyType:"private-key",entropyId:w,entropyIdVerifier:f,wallet:{keypair:e,address:e.publicKey.toBase58()},walletIndex:void 0,entropy:r},o=r}else if("solana-address-verifier"===f){let{reconstructedKeypair:e,reconstructedEntropy:r}=await (0,i.M4)({shares:[M,a.K3.decode(N)],expectedPublicKey:w,index:0});t={chainType:"solana",entropyType:"hd-entropy",entropyId:w,entropyIdVerifier:f,wallet:{keypair:e,address:e.publicKey.toBase58()},walletIndex:0,entropy:r},o=r}else throw new c.Pi("error","Failed to recover wallet: entropyIdVerifier ".concat(f," not supported"));let G=(0,i.hE)(),[L,B]=await (0,i.uY)(o),V=a.K3.encode(B);return await s.Dz({userId:y,appId:n,appClientId:d,accessToken:v,entropyId:w,entropyIdVerifier:f,deviceId:G,deviceAuthShare:V}),l.A.set({appId:n,userId:y,address:w},{share:a.K3.encode(L),deviceId:G}),t}async function I(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:n,recoveryKeyHash:i,mfaToken:d}=e;try{let[e,c]=await Promise.all([s.bz({appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:n,mfaToken:d}),s.So({appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:n,recoveryKeyHash:i})]);return{recoveryAuthShare:e.share,encryptedRecoveryShare:c.encrypted_recovery_share,encryptedRecoveryShareIV:c.encrypted_recovery_share_iv,imported:c.imported}}catch(e){var l;if((null===(l=e.response)||void 0===l?void 0:l.status)===400)throw new c.Pi("invalid_recovery_pin","Failed to recover wallet: invalid recovery pin");if((0,c.$J)(e))throw new c.Pi("missing_or_invalid_mfa","MFA verification failed");throw new c.Pi("error","Failed to recover wallet: unknown error")}}var T=t(17890),A=t(40049);let S=e=>{throw Error("Expected never got ".concat(e))};var E=t(1048).Buffer;async function K(e){let{appId:r,appClientId:t,userId:o,accessToken:n,clientType:y,entropy:v,entropyId:p,entropyIdVerifier:w,recoveryOptions:f,createWalletEvent:_}=e,h=d[f.recoveryMethod];f.existingRecoveryMethod&&function(e){let{currentRecoveryMethod:r,upgradeToRecoveryMethod:t}=e;switch(r){case"privy_generated_recovery_key":case"user_passcode_derived_recovery_key":case"privy_passcode_derived_recovery_key":return;case"icloud_recovery_secret":case"google_drive_recovery_secret":if(r===t)throw Error("Cannot upgrade to the existing cloud platform");return;default:S(r)}}({currentRecoveryMethod:d[f.existingRecoveryMethod],upgradeToRecoveryMethod:h});let m=(0,u.Zw)({recoveryType:h,appId:r,appClientId:t,userId:o,entropyId:p,clientType:y,accessToken:n,createWalletEvent:_,recoveryPassword:"user-passcode"===f.recoveryMethod?f.recoveryPassword:void 0,recoveryAccessToken:"google-drive"===f.recoveryMethod||"icloud"===f.recoveryMethod?f.recoveryAccessToken:void 0,recoverySecretOverride:"icloud-native"===f.recoveryMethod?f.recoverySecretOverride:void 0,iCloudRecordNameOverride:"icloud-native"===f.recoveryMethod?f.iCloudRecordNameOverride:void 0}),g=l.A.get({appId:r,userId:o,address:p});if(!g)throw new c.Pi("wallet_not_on_device","Failed to initialize wallet: wallet with address '".concat(p,"' not loaded on this device"));let[b,k]=await Promise.all([(0,i.uY)(v),(0,i.uY)(v)]),[P,I]=b,[T,A]=k;await x({shares:[T,A],entropyId:p,entropyIdVerifier:w});let[E,{encryptionKey:K,walletRecoveryOutput:C}]=await Promise.all([s.QQ({appId:r,appClientId:t,accessToken:n,address:p,chainType:"ethereum-address-verifier"===w?"ethereum":"solana"}),(0,u.cq)(m)]),[U,R]=await Promise.all([(0,i.EN)(K),(0,i.vb)(T,K)]),[N,{message:q,signature:O}]=await Promise.all([(0,u.qz)(C),F({nonce:E,entropy:v,entropyId:p,entropyIdVerifier:w})]);return await s.p5({appId:r,appClientId:t,accessToken:n,data:{entropyIdVerifier:w,message:q,signature:O,device_id:g.deviceId,device_auth_share:a.K3.encode(I),recovery_type:h,recovery_auth_share:a.K3.encode(A),encrypted_recovery_share:a.K3.encode(R.encryptedShare),encrypted_recovery_share_iv:a.K3.encode(R.encryptedShareIV),recovery_key_hash:a.K3.encode(U),...N}}),l.A.set({appId:r,userId:o,address:p},{share:a.K3.encode(P),deviceId:g.deviceId}),{entropy:v,entropyId:p,entropyIdVerifier:w,entropyType:"hd-entropy"}}async function x(e){let{entropyIdVerifier:r,shares:t,entropyId:a}=e;"solana-address-verifier"===r?await (0,i.M4)({shares:t,expectedPublicKey:a,index:0}):await (0,i.p$)({shares:t,primaryAddress:a,walletIndex:0})}async function F(e){let{nonce:r,entropy:t,entropyId:o,entropyIdVerifier:s}=e;if("solana-address-verifier"===s){let e=(0,i.zT)(window.location.host,window.location.origin,o,r),s=(0,i.kG)({entropy:t,index:0}),c=n().sign.detached(E.from(e),s.secretKey);return{message:e,signature:a.K3.encode(c)}}{let e=(0,i.t5)(window.location.host,window.location.origin,o,r),a=(0,i.Ay)({entropy:t,walletIndex:0}),n=await a.signMessage({message:e});return{message:e,signature:n}}}},28933:(e,r,t)=>{"use strict";t.d(r,{A:()=>n});var a=t(30066);class o extends a.i{set(e,r){let t=this.getMfaTokenStorageKey(e);this._set(t,r)}get(e){let r=this.getMfaTokenStorageKey(e);return this._get(r)}del(e){let r=this.getMfaTokenStorageKey(e);this._del(r)}getMfaTokenStorageKey(e){let{appId:r,userId:t}=e;return"privy:mfa:".concat(r,":").concat(t)}constructor(e){super(e)}}let n=(()=>{try{if("undefined"!=typeof globalThis&&globalThis.localStorage)return new o(globalThis.localStorage)}catch(e){e instanceof DOMException&&"SecurityError"===e.name?console.debug("Security settings in your browser prevent access to local storage, used for persisting wallet state. Wallet information will be stored in-memory."):console.debug("Unknown issue loading local storage, used for persisting wallet state. Wallet information will be stored in-memory.")}return new o(new a._)})()},44637:(e,r,t)=>{"use strict";t.d(r,{A:()=>y});var a=t(28192),o=t(36073),n=t(58055),i=t(39535),s=t(85451),c=t(62729);let d=e=>{var r;return(null===(r=e.data)||void 0===r?void 0:r.code)==="device_revoked"};async function l(e){let r,t,{accessToken:a,appId:l,appClientId:u,clientAnalyticsId:y,userId:v,mfaToken:p,entropyId:w,entropyIdVerifier:f}=e,_={appId:l,userId:v,address:w},h=c.A.get(_);if(!h)return null;let{share:m,deviceId:g}=h;try{let e=await s.u({appId:l,appClientId:u,accessToken:a,clientAnalyticsId:y,mfaToken:p,deviceId:g,entropyId:w,entropyIdVerifier:f});r=e.share,t=e.imported}catch(e){if(d(e))return c.A.del(_),null;throw e}try{let e=await (0,n.k)([o.K3.decode(m),o.K3.decode(r)]);if("ethereum-address-verifier"===f&&t){let r=(0,i.st)({entropy:e});if(!(0,i.LH)(w,r.address))throw Error("Failed to reconstruct the expected wallet from Shamir shares")}else if("ethereum-address-verifier"===f){let r=(0,i.Ay)({entropy:e,walletIndex:0});if(!(0,i.LH)(w,r.address))throw Error("Failed to reconstruct the expected wallet from Shamir shares")}else if("solana-address-verifier"===f&&t){if((0,i.Wi)({entropy:e}).publicKey.toBase58()!==w)throw Error("Failed to reconstruct the expected public key from Shamir shares.")}else if("solana-address-verifier"===f&&(0,i.kG)({entropy:e,index:0}).publicKey.toBase58()!==w)throw Error("Failed to reconstruct the expected public key from Shamir shares.");return{entropy:e,entropyType:t?"private-key":"hd-entropy"}}catch(e){return c.A.del(_),null}}var u=t(84011);async function y(e){let{accessToken:r,appId:t,appClientId:o,clientAnalyticsId:n,userId:i,mfaCode:s,mfaMethod:c,relyingParty:d,entropyId:y,entropyIdVerifier:v,cache:p}=e,w=await (0,u.X)({appId:t,appClientId:o,userId:i,accessToken:r,mfaMethod:c,mfaCode:s,relyingParty:d});if(p&&!w&&p.entropyId===y)return{entropy:p.entropy,entropyType:p.entropyType};let f=await l({appId:t,clientAnalyticsId:n,appClientId:o,userId:i,accessToken:r,entropyId:y,entropyIdVerifier:v,mfaToken:w});if(!f)throw new a.Pi("wallet_not_on_device","Failed to initialize: '".concat(y,"' not loaded on this device"));return f}},84011:(e,r,t)=>{"use strict";t.d(r,{X:()=>i});var a=t(85451),o=t(28192),n=t(28933);async function i(e){var r;let{appId:t,appClientId:i,userId:s,accessToken:c,mfaMethod:d,mfaCode:l,relyingParty:u}=e,y=null===(r=n.A.get({appId:t,userId:s}))||void 0===r?void 0:r.token;if(l&&d)try{let e=await a.j2({appId:t,appClientId:i,accessToken:c,method:d,code:l,relyingParty:u});n.A.set({appId:t,userId:s},e),y=e.token}catch(e){throw new o.Pi("missing_or_invalid_mfa","MFA verification failed")}return null!=y?y:null}},10280:(e,r,t)=>{"use strict";t.d(r,{Zw:()=>c,cq:()=>d,qz:()=>l});var a=t(36073),o=t(39535),n=t(28192),i=t(47670),s=t(24015);function c(e){let{recoveryType:r,appId:t,appClientId:a,userId:i,entropyId:s,accessToken:c,clientType:d,recoveryPassword:l,recoveryAccessToken:u,recoverySecretOverride:y,iCloudRecordNameOverride:v,createWalletEvent:p}=e;if("user_passcode_derived_recovery_key"===r){if(!l||!(0,o.jt)(l))throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing or invalid recovery password");if(u)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery access token should not be provided for user recovery secret protected wallets.");return{recoveryType:r,recoveryPassword:l}}if("privy_generated_recovery_key"===r){if(l)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for privy generated recovery key wallets.");if(u)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery access token should not be provided for privy generated recovery key wallets.");return{recoveryType:r}}if("google_drive_recovery_secret"===r){if(!u)throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token");if(l)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for google drive recovery secret protected wallets.");return{recoveryType:r,recoveryAccessToken:u,appId:t,userId:i,entropyId:s}}if("icloud_recovery_secret"===r){if(!(u||y&&v))throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token or value overrides");if(l)throw new n.Pi("invalid_request_arguments","Failed to create wallet: recovery password should not be provided for iCloud recovery secret protected wallets.");if(!["web","expo-ios"].includes(d))throw new n.Pi("invalid_request_arguments","Failed to create wallet: client type ".concat(d," is not supported for iCloud recovery"));return{recoveryType:r,recoveryAccessToken:null!=u?u:null,appId:t,appClientId:a,userId:i,entropyId:s,customerAccessToken:c,clientType:d,recoverySecretOverride:null!=y?y:null,iCloudRecordNameOverride:null!=v?v:null,createWalletEvent:p}}throw new n.Pi("invalid_request_arguments","Failed to create wallet: unknown recovery type: ".concat(r))}async function d(e){let{recoveryType:r}=e;if("user_passcode_derived_recovery_key"===r){let{recoveryPassword:t}=e,a=(0,o.s5)();return{encryptionKey:await (0,o.Ud)(t,a),walletRecoveryOutput:{recoveryType:r,recoveryKeyDerivationSalt:a}}}if("privy_generated_recovery_key"===r){let e=await (0,o.CI)();return{encryptionKey:e,walletRecoveryOutput:{recoveryType:r,encryptionKey:e}}}if("google_drive_recovery_secret"===r){let t;let{recoveryAccessToken:s}=e,c=await (0,o.CI)(),d=a.K3.encode(await (0,o.WQ)(c)),l=await (0,i.w5)({appId:e.appId,userId:e.userId,entropyId:e.entropyId});try{t=await (0,i.Vz)(s,{recoverySecret:d,filename:l})}catch(r){let e=r instanceof Error?r.message:"Provider error";throw new n.Pi("error","Failed to write recovery secret to Google Drive: ".concat(e))}return{encryptionKey:c,walletRecoveryOutput:{recoveryType:r,filename:l,fileId:t}}}if("icloud_recovery_secret"===r){let t;let{recoveryAccessToken:i,entropyId:c,appId:d,appClientId:l,userId:u,customerAccessToken:y,clientType:v,recoverySecretOverride:p,iCloudRecordNameOverride:w}=e;if(p&&!w||!p&&w)throw new n.Pi("invalid_request_arguments","Failed to create wallet: both recovery secret and iCloud record name must be provided if one is provided.");if(p&&w)return{encryptionKey:await (0,o.kS)(a.K3.decode(p)),walletRecoveryOutput:{recoveryType:r,recordName:w}};if(!i)throw new n.Pi("invalid_request_arguments","Failed to create wallet: missing recovery access token for iCloud recovery");let f=await (0,o.CI)(),_=a.K3.encode(await (0,o.WQ)(f));try{let{cloudKitContainerIdentifier:e,cloudKitEnvironment:r,cloudKitApiToken:a}=await (0,s.hf)(d,l,y,v);t=await (0,s.yt)({ckWebAuthToken:i,recoverySecretToStore:_,entropyId:c,appId:d,userId:u,cloudKitContainerIdentifier:e,cloudKitEnvironment:r,cloudKitApiToken:a})}catch(t){if((0,n.dS)(t))throw e.createWalletEvent(t.eventInfo.eventName,t.eventInfo.payload),t.convert();let r=t instanceof Error?t.message:"Provider error";throw new n.Pi("error","Failed to write recovery secret to iCloud: ".concat(r))}return{encryptionKey:f,walletRecoveryOutput:{recoveryType:r,recordName:t}}}throw Error("Unknown recovery type.")}async function l(e){let{recoveryType:r}=e;if("user_passcode_derived_recovery_key"===r){let{recoveryKeyDerivationSalt:r}=e;return{recovery_key_derivation_salt:a.K3.encode(r)}}if("privy_generated_recovery_key"===r){let{encryptionKey:r}=e;return{recovery_key:a.K3.encode(await (0,o.WQ)(r))}}if("google_drive_recovery_secret"===r){let{filename:r,fileId:t}=e;return{filename:r,file_id:t}}if("icloud_recovery_secret"===r){let{recordName:r}=e;return{icloud_record_name:r}}throw Error("Unknown recovery type: ".concat(r))}},91162:(e,r,t)=>{"use strict";t.d(r,{q:()=>n,d:()=>i});var a=t(55945);let o={att:"pat"};function n(e,r){return a.RD(new URL("/api/v1/apps/".concat(e,"/jwks.json"),r))}async function i(e,r,t){if(!e)return console.error("No access token provided."),null;try{var a;let o=await s(e,t,r),n=(a=o.payload.sub,"string"==typeof a&&/^did:privy:.+/.test(a)?a.replace(/^did:privy:/,""):null);if(!n)return console.error("Unable to decode user ID. Audience claim:",o.payload.aud),null;if(!o.payload.aud)return console.error("Access token does not contain an audience claim."),null;return console.debug("Successfully verified access token."),{userId:n,appId:t}}catch(e){return console.error(e),null}}async function s(e,r,t){let n={typ:"JWT",algorithms:["ES256"],issuer:"privy.io"},i=a.iU(e).att===o.att;i||(n.audience=r);let s=await a.Vv(e,t,n);if(i&&s.payload.aid!==r)throw Error("Access token does not have correct appId");return s}},85451:(e,r,t)=>{"use strict";t.d(r,{$1:()=>T,AI:()=>D,Dz:()=>I,IV:()=>u,IW:()=>p,NB:()=>K,O:()=>A,QQ:()=>d,So:()=>b,St:()=>S,Zn:()=>v,_o:()=>x,aV:()=>O,bz:()=>m,gc:()=>l,hH:()=>C,j:()=>g,j2:()=>q,jE:()=>F,p5:()=>w,q$:()=>E,ry:()=>y,u:()=>_});var a=t(2963),o=t(48016),n=t(28933);let i=e=>{var r;let t=new a.F(null===(r=e.response._data)||void 0===r?void 0:r.error);for(let r of["request","options","response"])Object.defineProperty(t,r,{get:()=>e[r]});for(let[r,a]of[["data","_data"],["status","status"],["statusCode","status"],["statusText","statusText"],["statusMessage","statusText"]])Object.defineProperty(t,r,{get:()=>e.response&&e.response[a]});throw t},s=async(e,r,t)=>await (0,o.OT)(e,{method:"POST",body:r,headers:t,timeout:9e3,credentials:"include",onResponseError:i}),c=async(e,r,t)=>await (0,o.OT)(e,{method:"PATCH",body:r,headers:t,timeout:9e3,credentials:"include",onResponseError:i});async function d(e){let{appId:r,appClientId:t,accessToken:a,address:o,chainType:n}=e;return(await s("/api/v1/embedded_wallets/init",{address:o,chain_type:n},M({appId:r,appClientId:t,accessToken:a}))).nonce}async function l(e){let{appId:r,appClientId:t,accessToken:a,data:o}=e;return await s("/api/v1/embedded_wallets",o,M({appId:r,appClientId:t,accessToken:a}))}async function u(e,r,t,a){return await s("/api/v1/embedded_wallets/add_solana",a,M({appId:e,appClientId:r,accessToken:t}))}async function y(e,r,t,a){return await s("/api/v1/embedded_wallets/add_ethereum",a,M({appId:e,appClientId:r,accessToken:t}))}async function v(e){let{appId:r,appClientId:t,accessToken:a,data:o}=e;return await s("/api/v1/embedded_wallets/add_wallet",o,M({appId:r,appClientId:t,accessToken:a}))}async function p(e){let{appId:r,appClientId:t,accessToken:a,data:o}=e;return await s("/api/v1/wallets/delegate",o,M({appId:r,appClientId:t,accessToken:a}))}async function w(e){let{appId:r,appClientId:t,accessToken:a,data:{entropyIdVerifier:o,...n}}=e;return await c("/api/v1/embedded_wallets",{...n,chain_type:L(o)},M({appId:r,appClientId:t,accessToken:a}))}let f=async e=>{let{appId:r,appClientId:t,clientAnalyticsId:o,accessToken:n,fn:i}=e;try{return await i()}catch(e){if(!(e instanceof a.F)||e.response)throw e;return T({appId:r,appClientId:t,clientId:o,accessToken:n,eventName:"retry_fetch_share_no_response",payload:{error:e.message}}),await i()}};async function _(e){let{appId:r,appClientId:t,clientAnalyticsId:a,accessToken:o,entropyId:n,entropyIdVerifier:i,deviceId:s,mfaToken:c}=e;return await f({appId:r,appClientId:t,accessToken:o,clientAnalyticsId:a,fn:()=>h({appId:r,appClientId:t,accessToken:o,entropyId:n,entropyIdVerifier:i,deviceId:s,mfaToken:c})})}async function h(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:n,deviceId:i,mfaToken:c}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/share"),{device_id:i,chain_type:L(n)},M({appId:r,appClientId:t,accessToken:a,mfaToken:c}))}async function m(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:n,mfaToken:i}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/recovery/auth_share"),{chain_type:L(n)},M({appId:r,appClientId:t,accessToken:a,mfaToken:i}))}async function g(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:n}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/recovery/key_material"),{chain_type:L(n)},M({appId:r,appClientId:t,accessToken:a}))}async function b(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:n,recoveryKeyHash:i}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/recovery/shares"),{recovery_key_hash:i,chain_type:L(n)},M({appId:r,appClientId:t,accessToken:a}))}async function k(e){let{appId:r,appClientId:t,accessToken:a,entropyId:o,entropyIdVerifier:n,deviceAuthShare:i,deviceId:c}=e;return await s("/api/v1/embedded_wallets/".concat(o,"/recovery/device"),{device_id:c,device_auth_share:i,chain_type:L(n)},M({appId:r,appClientId:t,accessToken:a}))}let P=e=>e&&e instanceof Error&&(e.message.includes("abort")||e.message.includes("timeout"));async function I(e){let{userId:r,appId:t,appClientId:a,accessToken:o,entropyId:i,entropyIdVerifier:s,deviceAuthShare:c,deviceId:d}=e;try{return await k({appId:t,appClientId:a,accessToken:o,entropyId:i,entropyIdVerifier:s,deviceAuthShare:c,deviceId:d})}catch(e){if(P(e)){var l,u;let{share:e}=await h({mfaToken:null!==(u=null===(l=n.A.get({appId:t,userId:r}))||void 0===l?void 0:l.token)&&void 0!==u?u:null,appId:t,appClientId:a,accessToken:o,entropyId:i,entropyIdVerifier:s,deviceId:d}).catch(()=>({share:null}));if(e)return{success:!0};return await k({appId:t,appClientId:a,accessToken:o,entropyId:i,entropyIdVerifier:s,deviceAuthShare:c,deviceId:d})}throw e}}function T(e){let{appId:r,appClientId:t,accessToken:a,clientId:o,eventName:n,payload:i,timestamp:c}=e;s("/api/v1/analytics_events",{event_name:n,client_id:o,payload:{...i||{},clientTimestamp:c?c.toISOString():new Date().toISOString()}},M({appId:r,appClientId:t,accessToken:a})).catch(()=>void 0)}async function A(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o}=e;return await s("/api/v1/mfa/totp/init",{action:"enroll"},M({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function S(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o,phoneNumber:n}=e;return await s("/api/v1/mfa/passwordless_sms/init",{phoneNumber:n,action:"enroll"},M({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function E(e){let{appId:r,appClientId:t,accessToken:a,code:o}=e;return await s("/api/v1/mfa/totp/enroll",{code:o},M({appId:r,appClientId:t,accessToken:a}))}async function K(e){let{appId:r,appClientId:t,accessToken:a,credentialIds:o,mfaToken:n}=e;return await s("/api/v1/mfa/passkeys/enrollment",{credential_ids:o},M({appId:r,appClientId:t,accessToken:a,mfaToken:n}))}async function x(e){let{appId:r,appClientId:t,accessToken:a,code:o,phoneNumber:n}=e;return await s("/api/v1/mfa/passwordless_sms/enroll",{phoneNumber:n,code:o},M({appId:r,appClientId:t,accessToken:a}))}async function F(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o}=e;return await s("/api/v1/mfa/passwordless_sms/unenroll",{},M({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function C(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o}=e;return await s("/api/v1/mfa/totp/unenroll",{},M({appId:r,appClientId:t,accessToken:a,mfaToken:o}))}async function U(e){let{appId:r,appClientId:t,accessToken:a,code:o}=e;return await s("/api/v1/mfa/passwordless_sms/verify",{code:o},M({appId:r,appClientId:t,accessToken:a}))}async function R(e){let{appId:r,appClientId:t,accessToken:a,code:o}=e;return await s("/api/v1/mfa/totp/verify",{code:o},M({appId:r,appClientId:t,accessToken:a}))}async function N(e){let{appId:r,appClientId:t,accessToken:a,authenticatorResponse:o,relyingParty:n}=e;return await s("/api/v1/mfa/passkeys/verify",{authenticator_response:o,relying_party:n},M({appId:r,appClientId:t,accessToken:a}))}async function q(e){let{appId:r,appClientId:t,accessToken:a,code:o,method:n,relyingParty:i}=e;switch(n){case"sms":return await U({appId:r,appClientId:t,accessToken:a,code:o});case"totp":return await R({appId:r,appClientId:t,accessToken:a,code:o});case"passkey":return await N({appId:r,appClientId:t,accessToken:a,relyingParty:i,authenticatorResponse:o});default:throw Error("Unknown mfa method: ".concat(n))}}async function O(e){let{appId:r,appClientId:t,signerPublicKey:a,auth:o}=e;return await s("/api/v1/farcaster/signer/init",{ed25519_public_key:a},M({appId:r,appClientId:t,accessToken:o.accessToken,mfaToken:o.mfaToken}))}async function D(e){let{appId:r,appClientId:t,accessToken:a,data:o}=e;return await s("/api/v1/recovery/configuration_icloud",{client_type:o.client_type},M({appId:r,appClientId:t,accessToken:a}))}function M(e){let{appId:r,appClientId:t,accessToken:a,mfaToken:o}=e,n=new Headers;return n.set("privy-app-id",r),n.set("authorization","Bearer ".concat(a)),t&&n.set("privy-client-id",t),o&&n.set("privy-mfa-token",o),n}let G={"ethereum-address-verifier":"ethereum","solana-address-verifier":"solana"},L=e=>G[e]},28192:(e,r,t)=>{"use strict";t.d(r,{$J:()=>d,Pi:()=>n,RO:()=>i,dS:()=>c,xR:()=>s,z6:()=>o});let a=["error","invalid_request_arguments","wallet_not_on_device","hd_wallet_required","invalid_recovery_pin","insufficient_funds","missing_or_invalid_mfa","twilio_verification_failed","no_icloud_record_found","multiple_icloud_records_found","unknown_icloud_recovery_error","unknown_icloud_storage_error"],o="error";class n extends Error{constructor(e,r){super(r),this.type=e}}class i extends n{convert(){return new n(this.type,this.message)}constructor(e,r,t){super(e,r),this.type=e,this.eventInfo=t}}function s(e){let r=e.type;return"string"==typeof r&&a.includes(r)}function c(e){return s(e)&&!!e.convert}function d(e){var r;let t=null===(r=e.data)||void 0===r?void 0:r.code;return"missing_or_invalid_mfa"===t||"expired_or_invalid_mfa_token"===t}},47670:(e,r,t)=>{"use strict";t.d(r,{Vz:()=>s,lT:()=>c,w5:()=>i});var a=t(36073),o=t(94335),n=t(39535);async function i(e){let{appId:r,userId:t,entropyId:o}=e,i=await (0,n.YZ)(o),s=a.K3.encode(i);return"privy-wallet-".concat(r,"-").concat(t,"-").concat(s,".txt")}async function s(e,r){let{recoverySecret:t,filename:a}=r,n="recovery-secret-boundary",i="\r\n--".concat(n,"\r\n"),s=i+"Content-Type: application/json; charset=UTF-8\r\n\r\n"+JSON.stringify({name:a,mimeType:"text/plain",parents:["appDataFolder"]})+i+"Content-Type: text/plain\r\n\r\n"+t+"\r\n--".concat(n,"--");return(await o.A.post("https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart",s,{headers:{"Content-Type":'multipart/related; boundary="'.concat(n,'"'),Authorization:"Bearer ".concat(e)}})).data.id}async function c(e,r){let{fileId:t}=r;return(await o.A.get("https://www.googleapis.com/drive/v3/files/".concat(t),{headers:{Authorization:"Bearer ".concat(e)},params:{alt:"media"},responseType:"text"})).data}},24015:(e,r,t)=>{"use strict";t.d(r,{WT:()=>d,hf:()=>s,yt:()=>c});var a=t(48016),o=t(85451),n=t(28192);let i="https://api.apple-cloudkit.com/database/1";async function s(e,r,t,a){let n=await (0,o.AI)({appId:e,appClientId:r,accessToken:t,data:{client_type:a}});return{cloudKitContainerIdentifier:n.container_identifier,cloudKitEnvironment:n.environment,cloudKitApiToken:n.api_token}}async function c(e){var r,t,o;let{ckWebAuthToken:s,recoverySecretToStore:c,entropyId:d,appId:l,userId:u,cloudKitContainerIdentifier:y,cloudKitEnvironment:v,cloudKitApiToken:p}=e,w=encodeURIComponent(s),f="".concat(i,"/").concat(y,"/").concat(v,"/private/records/modify?ckAPIToken=").concat(p,"&ckWebAuthToken=").concat(w),_=await a.OT.raw(f,{method:"POST",body:{operations:[{operationType:"create",record:{recordType:"PrivyWallets",fields:{recovery_secret:{value:c},wallet_address:{value:d},app_id:{value:l},user_id:{value:u}}}}]},headers:{"Content-Type":"application/json"},ignoreResponseError:!0});if(!(null==_?void 0:null===(r=_._data)||void 0===r?void 0:r.records)||(null==_?void 0:null===(t=_._data)||void 0===t?void 0:t.records.length)===0||!(null===(o=_._data.records)||void 0===o?void 0:o[0]))throw new n.RO("no_icloud_record_found","Failed to store wallet: unknown issue storing recovery secret",{eventName:"icloud_write_error",payload:{detail:"no_icloud_record_found"}});if(_._data.records.length>1)throw new n.RO("multiple_icloud_records_found","Failed to store wallet: multiple iCloud records found for the user",{eventName:"icloud_write_error",payload:{detail:"multiple_icloud_records_found"}});let h=_._data.records[0];if("serverErrorCode"in h)throw console.warn("Unable to store with iCloud: ".concat(h.reason)),new n.RO("unknown_icloud_storage_error","Failed to store wallet: iCloud errored with code ".concat(h.serverErrorCode),{eventName:"icloud_write_error",payload:{detail:"icloud_server_issue",icloud_error_code:h.serverErrorCode,icloud_status:_.status,icloud_error_uuid:h.uuid}});if(_.status>=400)throw new n.RO("unknown_icloud_storage_error","Failed to store wallet: issue storing recovery secret",{eventName:"icloud_write_error",payload:{detail:"unknown_icloud_server_issue",icloud_status:_.status}});if(c!==h.fields.recovery_secret.value)throw new n.RO("unknown_icloud_storage_error","Failed to store wallet: iCloud stored wallet address does not match expected address.",{eventName:"icloud_write_error",payload:{detail:"wallet_address_mismatch"}});return h.recordName}async function d(e){var r,t,o;let{ckWebAuthToken:s,recordName:c,entropyId:d,cloudKitContainerIdentifier:l,cloudKitEnvironment:u,cloudKitApiToken:y,createWalletEvent:v}=e,p=encodeURIComponent(s),w="".concat(i,"/").concat(l,"/").concat(u,"/private/records/lookup?ckAPIToken=").concat(y,"&ckWebAuthToken=").concat(p),f=await a.OT.raw(w,{method:"POST",body:{records:{recordName:c}},headers:{"Content-Type":"application/json"},ignoreResponseError:!0});if(!(null==f?void 0:null===(r=f._data)||void 0===r?void 0:r.records)||(null==f?void 0:null===(t=f._data)||void 0===t?void 0:t.records.length)===0||!(null===(o=f._data.records)||void 0===o?void 0:o[0]))throw v("icloud_recovery_error",{detail:"no_icloud_record_found"}),new n.Pi("no_icloud_record_found","Failed to recover wallet: expected an iCloud recovery record, user possibly selected the wrong iCloud account");if(f._data.records.length>1)throw v("icloud_recovery_error",{detail:"multiple_icloud_records_found"}),new n.Pi("multiple_icloud_records_found","Failed to recover wallet: multiple iCloud records found for the user");let _=f._data.records[0];if("serverErrorCode"in _)throw v("icloud_recovery_error",{detail:"icloud_server_issue",icloud_error_code:_.serverErrorCode,icloud_status:f.status,icloud_error_uuid:_.uuid}),console.warn("Unable to recover with iCloud: ".concat(_.reason)),new n.Pi("unknown_icloud_recovery_error","Failed to recover wallet: iCloud errored with code ".concat(_.serverErrorCode));if(f.status>=400)throw v("icloud_recovery_error",{detail:"unknown_icloud_server_issue",icloud_status:f.status}),new n.Pi("unknown_icloud_recovery_error","Failed to recover wallet: issue fetching recovery secret");if(d!==_.fields.wallet_address.value)throw v("icloud_recovery_error",{detail:"wallet_address_mismatch"}),new n.Pi("unknown_icloud_recovery_error","Failed to recover wallet: iCloud stored wallet address does not match expected address.");return _.fields.recovery_secret.value}},75185:(e,r,t)=>{"use strict";t.d(r,{p:()=>s,x:()=>i});var a=t(82926),o=t.n(a),n=t(1048).Buffer;async function i(e,r,t){!function(e,r){if(e.toString()!==r)throw Error("Signer ".concat(e.toBase58()," cannot sign on behalf of ").concat(r))}(e.publicKey,r);let a=n.from(t,"base64");try{let r=o().sign.detached(a,e.secretKey);return n.from(r).toString("base64")}catch(e){throw console.error(e),e}}async function s(e){let{keypair:r,request:t,expectedPublicKey:a}=e,{method:o,params:n}=t;if("signMessage"===o)return{method:o,data:{signature:await i(r,a,n.message)}};throw Error("Unsupported method: ".concat(o))}},30066:(e,r,t)=>{"use strict";t.d(r,{_:()=>a,i:()=>o});class a{get length(){return Object.keys(this.data).length}getItem(e){let r=this.data[e];return void 0!==r?r:null}setItem(e,r){this.data[e]=String(r)}removeItem(e){delete this.data[e]}clear(){this.data={}}constructor(){this.data={}}}class o{_set(e,r){this.storage.setItem(e,JSON.stringify(r))}_get(e){let r=this.storage.getItem(e);if("string"!=typeof r)return null;try{return JSON.parse(r)}catch(r){return this.storage.removeItem(e),null}}_del(e){this.storage.removeItem(e)}constructor(e){this.storage=e}}},92445:(e,r,t)=>{"use strict";t.d(r,{E:()=>s});var a=t(95986),o=t(95210),n=t(89414),i=t(69193);function s(e){let{entropy:r,index:t,pathType:s}=e,d=a.c.fromMasterSeed((0,o.kw)((0,o.VF)(r,n.p))).derive(c(t,s));if(!d.publicKey||!d.privateKey)throw Error("Error deriving HD node for entropy");let l="taproot"===s?(0,i.bv)("tr",d.privateKey):(0,i.bv)("wpkh",d.privateKey);if(!l)throw Error("Error deriving address from private key");return{_node:d,address:l,privateKey:d.privateKey,publicKey:d.publicKey}}let c=(e,r)=>"taproot"===r?"m/86'/0'/0'/0/".concat(e):"m/84'/0'/0'/0/".concat(e)},39535:(e,r,t)=>{"use strict";t.d(r,{Ay:()=>K,Bt:()=>g,CD:()=>W,CI:()=>V,EN:()=>Z,IV:()=>P,IX:()=>R,LH:()=>S,M4:()=>q,MC:()=>Y,MR:()=>m,Pp:()=>U,UI:()=>b,Ud:()=>B,WQ:()=>j,Wi:()=>C,YZ:()=>J,Zf:()=>T,eB:()=>x,fj:()=>H,hE:()=>L,jt:()=>h,kG:()=>N,kS:()=>z,nz:()=>ee,p$:()=>E,py:()=>A,qi:()=>I,s5:()=>G,sr:()=>k,st:()=>F,t5:()=>D,uY:()=>O,vb:()=>$,zT:()=>M});var a=t(36073),o=t(95210),n=t(89414),i=t(3834),s=t(8448),c=t(58055),d=t(46394),l=t(29873),u=t(64569),y=t(84192),v=t(80815),p=t(66505),w=t(75185),f=t(1048).Buffer;function _(e){return crypto.getRandomValues(new Uint8Array(e))}function h(e){return"string"==typeof e&&/^[a-zA-Z0-9!@#$%^&*()\-_+.]{6,}$/.test(e)}async function m(e){return{deviceShares:await O(e),recoveryShares:await O(e)}}async function g(e){let r=new Uint8Array(f.from(e,"hex").buffer),{deviceShares:t,recoveryShares:a}=await m(r),o=(0,v.R)((0,d.q)(e)?e:"0x".concat(e));return{chainType:"ethereum",deviceShares:t,recoveryShares:a,wallet:o,entropy:r,signMessage:o.signMessage}}async function b(e){let r=a.tw.decode(e),{deviceShares:t,recoveryShares:o}=await m(r),n=i.AX.fromSecretKey(r),s=n.publicKey.toBase58();return{chainType:"solana",deviceShares:t,recoveryShares:o,wallet:n,address:s,signMessage:e=>{let{message:r}=e;return(0,w.x)(n,s,f.from(r).toString("base64"))},entropy:r}}async function k(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:128;if(![128,160,192,224,256].includes(e))throw Error("invalid entropy size");let r=_(e/8),{deviceShares:t,recoveryShares:a}=await m(r),o=K({entropy:r,walletIndex:0});return{entropy:r,deviceShares:t,recoveryShares:a,wallet:o}}async function P(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:256;if(![256].includes(e))throw Error("invalid entropy size");let r=_(e/8),{deviceShares:t,recoveryShares:a}=await m(r);return{deviceShares:t,recoveryShares:a,keypair:N({entropy:r,index:0}),entropy:r}}function I(e){return(0,l.P)(e)}function T(e){try{let r=new i.J3(e);return i.J3.isOnCurve(r)}catch(e){return!1}}function A(e){return(0,u.b)(e)}function S(e,r){return A(e)===A(r)}async function E(e){let{shares:r,primaryAddress:t,walletIndex:a}=e,o=await (0,c.k)(r),n=K({entropy:o,walletIndex:a});if(!S(0===a?n.address:K({entropy:o,walletIndex:0}).address,t))throw Error("Failed to reconstruct the expected wallet from Shamir shares");return{chainType:"ethereum",entropyType:"hd-entropy",wallet:n,entropy:o,walletIndex:a}}function K(e){let{entropy:r,walletIndex:t}=e;return x({entropy:r,opts:{addressIndex:t}})}function x(e){let{entropy:r,opts:t}=e;return(0,p.f)((0,o.VF)(r,n.p),t)}function F(e){let{entropy:r}=e;return(0,v.R)((0,y.nj)(r))}function C(e){let{entropy:r}=e;return i.AX.fromSecretKey(r)}async function U(e){let{shares:r,expectedAddress:t}=e,a=await (0,c.k)(r),o=F({entropy:a});if(o.address!==t)throw Error("Failed to reconstruct the expected address from Shamir shares.");return{reconstructedWallet:o,reconstructedPrivateKey:a}}async function R(e){let{shares:r,expectedAddress:t}=e,a=await (0,c.k)(r),o=i.AX.fromSecretKey(a);if(o.publicKey.toBase58()!==t)throw Error("Failed to reconstruct the expected address from Shamir shares.");return{reconstructedKeypair:o,reconstructedPrivateKey:a}}function N(e){let{entropy:r,index:t}=e,a=s.cf.fromMasterSeed(f.from(r).toString("hex"));return i.AX.fromSeed(a.derive("m/44'/501'/".concat(t,"'/0'")).privateKey)}async function q(e){let{shares:r,expectedPublicKey:t,index:a}=e,o=await (0,c.k)(r),n=N({entropy:o,index:a});if((0===a?n:N({entropy:o,index:0})).publicKey.toBase58()!==t)throw Error("Failed to reconstruct the expected public key from Shamir shares.");return{reconstructedKeypair:n,reconstructedEntropy:o}}function O(e){return(0,c.l)(e,2,2)}function D(e,r,t,a){return"".concat(e," wants you to sign in with your Ethereum account:\n").concat(t,"\n\nYou are proving you own ").concat(t,".\n\nURI: ").concat(r,"\nVersion: 1\nChain ID: 1\nNonce: ").concat(a,"\nIssued At: ").concat(new Date().toISOString(),"\nResources:\n- https://privy.io")}function M(e,r,t,a){return"".concat(e," wants you to sign in with your Solana account:\n").concat(t,"\n\nYou are proving you own ").concat(t,".\n\nURI: ").concat(r,"\nVersion: 1\nChain ID: mainnet\nNonce: ").concat(a,"\nIssued At: ").concat(new Date().toISOString(),"\nResources:\n- https://privy.io")}function G(){return _(32)}function L(){return a.tw.encode(_(16))}function B(e,r){return er(eo(e),r)}function V(){return crypto.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function j(e){return new Uint8Array(await crypto.subtle.exportKey("raw",e))}function z(e){return crypto.subtle.importKey("raw",e,"AES-GCM",!0,["encrypt","decrypt"])}async function W(){return await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"])}async function Y(e){return function(e,r){let t=Q(e),a=t.match(/.{1,64}/g),o=a?a.join("\n"):t;return"-----BEGIN ".concat(r,"-----\n")+o+"\n-----END ".concat(r,"-----")}(await crypto.subtle.exportKey("spki",e),"PUBLIC KEY")}async function H(e){return Q(await crypto.subtle.exportKey("pkcs8",e))}function Q(e){return btoa(String.fromCharCode(...new Uint8Array(e)))}async function Z(e){let r=await crypto.subtle.exportKey("raw",e);return await X(r)}async function J(e){let r=eo(e);return await X(r)}async function X(e){return new Uint8Array(await crypto.subtle.digest("SHA-256",e))}async function $(e,r){let t=_(12);return{encryptedShare:await et(e,t,r),encryptedShareIV:t}}function ee(e,r,t){return ea(e,r,t)}async function er(e,r){if(32!==r.byteLength)throw Error("pbkdf2 salt length should be 32 bytes");let t=await crypto.subtle.importKey("raw",e,"PBKDF2",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,hash:"SHA-512",iterations:21e5},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}async function et(e,r,t){return new Uint8Array(await crypto.subtle.encrypt({iv:r,name:"AES-GCM"},t,e))}async function ea(e,r,t){return new Uint8Array(await crypto.subtle.decrypt({iv:r,name:"AES-GCM"},t,e))}function eo(e){return new TextEncoder().encode(e)}},76094:(e,r,t)=>{"use strict";function a(e){return e.charAt(0).toUpperCase()+e.slice(1)}t.d(r,{Yq:()=>o,Zr:()=>a,j8:()=>i,lM:()=>d,vz:()=>n,yy:()=>s});let o=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{weekday:"long",year:"numeric",month:"short",day:"numeric"};return new Date(1e3*e).toLocaleDateString("en-us",r)},n=e=>{if(!e)return"";let r=e.slice(0,5),t=e.slice(e.length-4,e.length);return"".concat(r,"...").concat(t)},i=function(e,r){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=new URL(r,e.endsWith("/")?e:"".concat(e,"/"));for(let[e,r]of Object.entries(t))a.searchParams.set(e,r);return a.href},s=(e,r)=>{let t=r?Math.floor(Math.random()*(2*r+1))-r:0;return new Promise(r=>setTimeout(r,e+t))},c=/\.g\.alchemy\.com/i;function d(e){return c.test(e)}},36262:()=>{},8379:()=>{},43167:()=>{},85367:()=>{},76928:()=>{},27976:()=>{}}]);